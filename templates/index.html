<!DOCTYPE html>
<html>

<head>
    <title>Trial Page</title>
    <style>
        /* Style for canvas pixels */
        .canvas-pixel {
            width: 1rem;
            height: 1rem;
            border: none;
            margin: 0;
            padding: 0;
            display: inline-block;
        }

        /* Style to remove space between inline-block elements */
        #canvas-container {
            font-size: 0;
            width: 28rem;
            border: 1px black dashed;
            /* Remove default font size */
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <br>
    <button onclick="generateArray();">Detect</button>
    <button onclick="location.reload();">Clear</button>
    <p id="prediction-result"></p> <!-- Paragraph to display prediction result -->

    <script>
        const container = document.getElementById('canvas-container');

        // Function to generate the grid
        function generateGrid(rows, cols) {
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'canvas-pixel';
                    container.appendChild(pixel);
                }
            }
        }

        generateGrid(28, 28); // Generate a 28x28 grid

        let isMousePressed = false; // Flag to track mouse press state

        // Function to color adjacent pixels
        function colorAdjacentPixels(pixel) {
            // Get the index of the hovered pixel
            const pixelIndex = Array.from(container.children).indexOf(pixel);
            const cols = 28; // Number of columns in the grid
            const adjacentIndices = [
                pixelIndex - cols - 1, pixelIndex - cols, pixelIndex - cols + 1,
                pixelIndex - 1, /* pixelIndex */ pixelIndex + 1,
                pixelIndex + cols - 1, pixelIndex + cols, pixelIndex + cols + 1
            ];

            // Color the adjacent pixels
            adjacentIndices.forEach(index => {
                const adjacentPixel = container.children[index];
                if (adjacentPixel) { // Check if the adjacent pixel exists
                    const bgColor = window.getComputedStyle(adjacentPixel).getPropertyValue('background-color');
                    if (bgColor !== 'rgb(0, 0, 0)') { // Check if background color is not black
                        adjacentPixel.style.backgroundColor = 'gray';
                    }
                }
            });

        }

        const pixels = document.querySelectorAll('.canvas-pixel');

        pixels.forEach(pixel => {
            pixel.addEventListener('mouseenter', () => {
                if (isMousePressed) {
                    pixel.style.backgroundColor = 'black'; // Color the current pixel
                    colorAdjacentPixels(pixel); // Color adjacent pixels
                }
            });
        });

        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Check if left mouse button is pressed
                isMousePressed = true;
            }
        });

        document.addEventListener('mouseup', () => {
            isMousePressed = false; // Reset mouse press state on mouse up event
        });

        // Function to generate and send the nested list to Flask
        function generateArray() {
            const gridArray = [];

            pixels.forEach(pixel => {
                let value;
                const color = pixel.style.backgroundColor;

                if (color === 'black') {
                    value = 2.5;
                } else if (color === 'white') {
                    value = 0;
                } else {
                    value = 0;
                }

                gridArray.push(value);
            });

            // Send the nested array to Flask using AJAX
            const xhr = new XMLHttpRequest();
            xhr.open("POST", "/predict", true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    const response = JSON.parse(xhr.responseText);
                    // Display the returned text inside the paragraph element
                    document.getElementById('prediction-result').textContent = response.message;
                }
            };
            xhr.send(JSON.stringify({ data: gridArray }));
        }
    </script>
</body>

</html>
